-do autocomplete      DONE
-refactor errorstore DONE
-make a ajax request to get current user name from window.CURRENT_USER_ID
-location input has this.props.locations that it used to find the user input
when he searches for a location
-location input will pass the location object to the location index item page
-location index item page will contain the review form
-location index item page will contain reviews
-refactor app component to a nav component DONE
-require user to be logged in to visit pages
-add dyno
-add icon
-domain name
-seed locations
-seed reviews
-style delete location and markers
-add average reviews                      DONE
-star rating instead of 4/5
-legend                                   DONE
-the world is your playground above map   DONE
-fade background picture

-delete markers        DONE
-add location wishes   DONE
-


var Store = require('flux/utils').Store,
    AppDispatcher = require('../dispatcher/dispatcher'),
    SessionConstants = require('../constants/SessionConstants'),
    _sessions = [],
    SessionStore = new Store(AppDispatcher);

SessionStore.fetchUser = function() {
  return _sessions[0];
},

SessionStore.createSession = function(session) {
  _sessions.push(session);
  SessionStore.__emitChange();
};

SessionStore.logoutSession = function(session) {
  _sessions = [];
  // SessionStore.__emitChange();
};

SessionStore.__onDispatch = function(payload) {
  switch (payload.actionType) {
    case SessionConstants.CREATE_SESSION:
      SessionStore.createSession(payload.session)
      break;
    case SessionConstants.LOGOUT_SESSION:
      SessionStore.logoutSession(payload.session)
      break;
    case SessionConstants.ERROR:
      // SessionStore.error(payload.response)
      SessionStore.__emitChange();
      break;
  }
};

module.exports = SessionStore
e



user homepages
locations={this.state.locations} userid={this.props.location.query.id}

locationinput
getInitialState: function() {
  console.log("in initial state")
  return { searchString: "", location: "", locations: LocationStore.all(), toggleError: 0 }
},

getLocationId: function(locationName) {
  var locations = this.props.locations;
  var location = locationName.trim().toLowerCase();
  for (var key in locations) {
    if (locations.hasOwnProperty(key)) {
      if (location === locations[key].name.trim().toLowerCase()) {
        return locations[key].id;
        break;
      };
    };
  };
},

updateState: function() {
  console.log("updating state")
  var id = this.getLocationId(this.state.searchString);
  this.setState({location: LocationStore.find(id)})
  console.log(this.state.location)
  // if (this.state.location) {
  //   var url = "/location/" + this.state.location.id;
  // };
  // var location = this.state.location
  // this.history.pushState(null, url, location)
  // debugger
  // this.history.push("/location/1")
},

componentDidMount: function() {
  this.updateLocation = LocationStore.addListener(this.updateState);
},

componentWillUnmount: function() {
  this.updateLocation.remove();
},

handleSubmit: function(e) {
  e.preventDefault();
  var id = this.getLocationId(this.state.searchString);

  if (id === undefined) {
    this.setState({toggleError: 1})
    var url = "/user/" + this.props.userid
    this.history.push(url)
    // this.setState({searchString: ""})
  } else {
    ApiUtil.fetchLocation(id);
    debugger
    // this.setState({location: LocationStore.find(id)});
  }
},

handleChange: function(e) {
  // this.setState({searchString: e.target.value})
},

// autoComplete: function() {
//   var locations = this.props.locations;
//   var locationNames = [];
//   for (var key in locations) {
//     if (locations.hasOwnProperty(key)) {
//       locationNames.push(locations[key].name)
//     };
//   };
//   var that = this;
//   $("#tags").autocomplete({
//     source: locationNames,
//     change: function(event, ui) {
//       if (ui.item) {
//         console.log("in here")
//         that.setState({searchString: ui.item.value})
//       } else {
//         alert("nope")
//       }
//     }
//   })
// },

review form
      <Route path="/review/new" component={ReviewForm} />

      <Link to="/review/new">Add Review</Link>



      <label>Location</label>
      <br></br>
      <input type="text" valueLink={this.linkState("location")}></input>
      <br></br><br></br>


      <div className="radio-btn">
        <input type="radio" name="rating" className="star-1" id="star-1" value="1" onChange={this.updateRating}></input>
        <label className="star-1" htmlFor="star-1">1</label>
        <input type="radio" name="rating" className="star-2" id="star-2" value="2" onChange={this.updateRating}></input>
        <label className="star-2" htmlFor="star-2">2</label>
        <input type="radio" name="rating" className="star-3" id="star-3" value="3" onChange={this.updateRating}></input>
        <label className="star-3" htmlFor="star-3">3</label>
        <input type="radio" name="rating" className="star-4" id="star-4" value="4" onChange={this.updateRating}></input>
        <label className="star-4" htmlFor="star-4">4</label>
        <input type="radio" name="rating" className="star-5" id="star-5" value="5" onChange={this.updateRating}></input>
        <label className="star-5" htmlFor="star-5">5</label>
        <span></span>
      </div>


      var map = new jvm.Map({
         container: $(this.refs.map),
         map: 'continents_mill',
         regionsSelectable: true,

         regionStyle: {
           initial: {
             fill: '#B8E186'
           },
           selected: {
             fill: '#F4A582'
           }
         },

         onRegionSelected: function(){
           if (window.localStorage) {
             window.localStorage.setItem(
               'jvectormap-selected-regions',
               JSON.stringify(map.getSelectedRegions())
             );
           }
         },

       });

       map.setSelectedRegions( JSON.parse( window.localStorage.getItem('jvectormap-selected-regions') || '[]' ) );


       <select name="region" className="preference-region" onChange={this.handleRegion} value={this.state.region}>
         <option>Choose your region</option>
         <option value="Africa">Africa</option>
         <option value="Asia">Asia</option>
         <option value="Europe">Europe</option>
         <option value="North America">North America</option>
         <option value="Oceania">Oceania</option>
         <option value="South America">South America</option>
       </select>



       var locations = this.props.locations,
           location;

         for (var key in locations) {
           if (locations.hasOwnProperty(key)) {
             if (locations[key].name.toLowerCase().match(userInput)) {
               location = locations[key]
               break;
             }
           }
         }

         if (location === undefined) {
           this.setState({toggleError: 1})
           // this.history.push("/user/" + this.props.userid)
         } else {
           ApiUtil.fetchLocation(location.id);
           this.history.pushState(null, '/location/' + location.id)
         }
